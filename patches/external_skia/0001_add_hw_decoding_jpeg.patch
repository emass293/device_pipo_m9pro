From 98ecf0d98fb5452b3cc67b3ebcc24f9a4341a629 Mon Sep 17 00:00:00 2001
From: netlars <netlars@gmx.de>
Date: Fri, 31 Oct 2014 19:24:05 +0100
Subject: [PATCH 2/2] add hw decoding jpeg

Change-Id: Ibe63082279ead7dce5c36b605485ecab4a47f2b1
---
 Android.mk                            |   7 +
 include/core/SkStream.h               |   1 +
 include/images/SkHwJpegUtility.h      |  86 +++++
 src/core/SkBitmapProcShader.cpp       |   2 +-
 src/core/SkStream.cpp                 |   4 +
 src/images/SkHwJpegUtility.cpp        | 688 ++++++++++++++++++++++++++++++++++
 src/images/SkImageDecoder_libjpeg.cpp | 276 ++++++++++++--
 7 files changed, 1035 insertions(+), 29 deletions(-)
 create mode 100755 include/images/SkHwJpegUtility.h
 create mode 100755 src/images/SkHwJpegUtility.cpp

diff --git a/Android.mk b/Android.mk
index b574ceb..098d5a7 100644
--- a/Android.mk
+++ b/Android.mk
@@ -617,6 +617,13 @@ LOCAL_C_INCLUDES := \
 	external/webp/include \
 	frameworks/base/opengl/include \
 	external/expat/lib
+	
+LOCAL_CFLAGS += -DUSE_HW_JPEG
+LOCAL_SRC_FILES += src/images/SkHwJpegUtility.cpp
+LOCAL_SHARED_LIBRARIES += libjpeghwdec
+LOCAL_C_INCLUDES += hardware/rk29/jpeghw/release/decoder_release \
+		hardware/rk29/libon2
+
 
 LOCAL_EXPORT_C_INCLUDE_DIRS := \
 	$(LOCAL_PATH)/include/config \
diff --git a/include/core/SkStream.h b/include/core/SkStream.h
index 50ed691..c29b1c9 100644
--- a/include/core/SkStream.h
+++ b/include/core/SkStream.h
@@ -68,6 +68,7 @@ public:
      *  or late (after the first unsuccessful read).
      */
     virtual bool isAtEnd() const = 0;
+    virtual bool markSupport();
 
     int8_t   readS8();
     int16_t  readS16();
diff --git a/include/images/SkHwJpegUtility.h b/include/images/SkHwJpegUtility.h
new file mode 100755
index 0000000..11f28d7
--- /dev/null
+++ b/include/images/SkHwJpegUtility.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2011 The RockChip Android Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SkHWJpegUtility_DEFINED
+#define SkHWJpegUtility_DEFINED
+
+#include "SkImageDecoder.h"
+#include "SkStream.h"
+
+extern "C" {
+	#include "vpu_mem.h"
+	#include "hw_jpegdecapi.h"	
+    //#include "jpeglib.h"
+    //#include "jerror.h"
+}
+
+//#include <setjmp.h>
+
+/* Our error-handling struct.
+ *
+*/
+//struct skjpeg_error_mgr : jpeg_error_mgr {
+//    jmp_buf fJmpBuf;
+//};
+
+
+//void skjpeg_error_exit(j_common_ptr cinfo);
+
+///////////////////////////////////////////////////////////////////////////
+/* Our source struct for directing jpeg to our stream object.
+*/
+struct sk_hw_jpeg_source_mgr:hw_jpeg_source_mgr {
+    sk_hw_jpeg_source_mgr(SkStream* stream, SkImageDecoder* decoder, HwJpegInputInfo* hwInfo, int vpuMem);
+    ~sk_hw_jpeg_source_mgr();
+
+    SkStream*   fStream;
+    //void*       fMemoryBase;
+    //size_t      fMemoryBaseSize;
+    //bool        fUnrefStream;
+    SkImageDecoder* fDecoder;
+	//const void* fBaseAddr;//if stream is memoryStream, fBaseAddr is not null
+    enum {
+        kBufferSize = 1024//4096
+    };
+    unsigned char    fBuffer[kBufferSize];
+};
+int sk_fill_thumb(HwJpegInputInfo* hwInfo, void * thumbBuf);
+
+class SkJpegVPUMemStream : public SkMemoryStream {
+public:
+	size_t bytesInStream;//if equal -1 , means the data in this stream is error
+	SkStream *baseStream;
+	SkJpegVPUMemStream(SkStream* stream, size_t* len);
+	virtual ~SkJpegVPUMemStream();
+	VPUMemLinear_t* getVpuMemInst();
+	void setNewMemory(VPUMemLinear_t* src, size_t size);
+private:
+	VPUMemLinear_t vpuMem;
+};
+
+class AutoScaleBitmap : public SkBitmap{
+public:
+	char reusebm;
+	uint32_t finalWidth;
+	uint32_t finalHeight;
+	SkBitmap* bm;
+	SkImageDecoder* fDecoder;
+	AutoScaleBitmap();
+	~AutoScaleBitmap();
+	void setSourceAndFinalWH(char reuse, uint32_t w, uint32_t h,	SkBitmap* bitmap, SkImageDecoder* decoder);
+};
+
+#endif
diff --git a/src/core/SkBitmapProcShader.cpp b/src/core/SkBitmapProcShader.cpp
index 2521b56..53b09cc 100644
--- a/src/core/SkBitmapProcShader.cpp
+++ b/src/core/SkBitmapProcShader.cpp
@@ -178,7 +178,7 @@ void SkBitmapProcShader::endContext() {
  * A display with a width of 1080 pixels requires a buffer size of at least 541,
  * to run uninterrupted.
  */
-#define BUF_MAX     576
+#define BUF_MAX     1024
 
 #define TEST_BUFFER_OVERRITEx
 
diff --git a/src/core/SkStream.cpp b/src/core/SkStream.cpp
index 3350f82..b0402eb 100644
--- a/src/core/SkStream.cpp
+++ b/src/core/SkStream.cpp
@@ -14,6 +14,10 @@
 #include "SkOSFile.h"
 
 ///////////////////////////////////////////////////////////////////////////////
+bool SkStream::markSupport(){
+    //for show whether support reset() or mark() in java, add by WH
+    return false;
+}
 
 
 int8_t SkStream::readS8() {
diff --git a/src/images/SkHwJpegUtility.cpp b/src/images/SkHwJpegUtility.cpp
new file mode 100755
index 0000000..3aa071b
--- /dev/null
+++ b/src/images/SkHwJpegUtility.cpp
@@ -0,0 +1,688 @@
+/*
+ * Copyright (C) 2011 The RockChip Android Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "SkHwJpegUtility.h"
+#include "SkCanvas.h"
+#ifdef DEBUG_HW_JPEG
+#include "utils/Log.h"
+#undef LOG_TAG
+#define LOG_TAG "SkHwJpegUtility"
+#define WHLOG LOGE
+#endif
+
+/////////////////////////////////////////////////////////////////////
+static void sk_init_source(HwJpegInputInfo* hwInfo) {
+    sk_hw_jpeg_source_mgr*  src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+    src->next_input_byte = (const unsigned char*)src->fBuffer;
+    src->bytes_in_buffer = 0;
+    src->cur_offset_instream = 0;
+    src->fStream->rewind();
+}
+
+#define LARGEST_LENGTH (16*1024) //the same to the size of stream limit in BitmapFactory.java
+
+static HW_BOOL sk_skip_input_data(HwJpegInputInfo* hwInfo, long num_bytes) {
+    sk_hw_jpeg_source_mgr*  src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+WHLOG("skip num_bytes: %d, cur offset : %d", num_bytes, src->cur_offset_instream);
+#if 0
+    if (num_bytes > (long)src->bytes_in_buffer) {
+        num_bytes = num_bytes - src->bytes_in_buffer;
+WHLOG("real skip bytes: %d, bytes_in_buffer: %d", num_bytes, src->bytes_in_buffer);
+		long bytesToSkip = sk_hw_jpeg_source_mgr::kBufferSize;
+		while(num_bytes > 0) {
+            long bytes = (long)src->fStream->skip(bytesToSkip);
+            if (bytes <= 0 || bytes > bytesToSkip) {
+                WHLOG("Error occure in skip input data.");
+                return false;
+            }
+            src->cur_offset_instream += bytes;
+            num_bytes -= bytes;
+WHLOG("skip: %d, and remain: %d", bytes, num_bytes);
+			if(num_bytes < sk_hw_jpeg_source_mgr::kBufferSize){
+				bytesToSkip = num_bytes;
+			}
+		}
+        src->next_input_byte = (const unsigned char*)src->fBuffer;
+        src->bytes_in_buffer = 0;
+    } else {
+        src->next_input_byte += num_bytes;
+        src->bytes_in_buffer -= num_bytes;
+    }
+#else
+	if (num_bytes > (long)src->bytes_in_buffer) {
+        long bytesToSkip = num_bytes - src->bytes_in_buffer;
+#if 1
+		if(hwInfo->justcaloutwh && (bytesToSkip + src->cur_offset_instream > LARGEST_LENGTH)){
+			WHLOG("skip over Largest length.");
+			return false;
+		}
+#endif
+        while (bytesToSkip > 0) {
+			long bytes = (long)src->fStream->skip(bytesToSkip);
+			
+            if (bytes <= 0 || bytes > bytesToSkip) {
+				SkDebugf("failure to skip request %d returned %d\n", bytesToSkip, bytes);
+                return false;
+            }
+            src->cur_offset_instream += bytes;
+            bytesToSkip -= bytes;
+        }
+        src->next_input_byte = (const unsigned char*)src->fBuffer;
+        src->bytes_in_buffer = 0;
+    } else {
+        src->next_input_byte += num_bytes;
+        src->bytes_in_buffer -= num_bytes;
+    }
+#endif
+WHALLLOG("skip finish, cur offset : %d", src->cur_offset_instream);
+	return true;
+}
+
+static HW_BOOL sk_seek_input_data(HwJpegInputInfo* hwInfo, long byte_offset) {
+    sk_hw_jpeg_source_mgr* src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+#if 0
+    if (byte_offset > src->cur_offset_instream) {
+		src->bytes_in_buffer = 0;
+		src->next_input_byte = (const unsigned char*)src->fBuffer;
+		if(! sk_skip_input_data(hwInfo, byte_offset - src->cur_offset_instream)){
+			WHLOG("seek error for skip : %d bytes",byte_offset - src->cur_offset_instream);
+			return false;		
+		}
+        //(void)src->fStream->skip(byte_offset - src->cur_offset_instream);
+    } else if(byte_offset < src->cur_offset_instream){
+		src->bytes_in_buffer = 0;
+		src->cur_offset_instream = 0;
+        src->fStream->rewind();
+		if(! sk_skip_input_data(hwInfo, byte_offset)){
+			WHLOG("seek error for skip : %d bytes from start",byte_offset);
+			return false;		
+		}
+        //(void)src->fStream->skip(byte_offset);
+    }
+#else
+	WHALLLOG("seek to : %d, cur offset: %d", byte_offset, src->cur_offset_instream);
+	if (byte_offset > src->cur_offset_instream) {
+        (void)src->fStream->skip(byte_offset - src->cur_offset_instream);
+    } else if(byte_offset < src->cur_offset_instream){
+        src->fStream->rewind();
+        (void)src->fStream->skip(byte_offset);
+    }
+#endif
+    src->cur_offset_instream = byte_offset;
+    src->next_input_byte = (const unsigned char*)src->fBuffer;
+    src->bytes_in_buffer = 0;
+    return true;
+}
+
+static HW_BOOL sk_fill_input_buffer(HwJpegInputInfo* hwInfo) {
+    sk_hw_jpeg_source_mgr* src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+WHALLLOG("fill input buffer start cur_offset: %d", src->cur_offset_instream);
+	size_t bytes = 0;
+#if 1
+	if(hwInfo->justcaloutwh && (src->cur_offset_instream + sk_hw_jpeg_source_mgr::kBufferSize > LARGEST_LENGTH)){
+		if(LARGEST_LENGTH <= src->cur_offset_instream){
+			WHLOG("check here, LARGEST_LENGTH <= src->cur_offset_instream");
+			return false;
+		}
+		bytes = src->fStream->read(src->fBuffer, LARGEST_LENGTH - src->cur_offset_instream);
+	}else{
+#endif
+    	bytes = src->fStream->read(src->fBuffer, sk_hw_jpeg_source_mgr::kBufferSize);
+#if 1	
+	}
+#endif
+    // note that JPEG is happy with less than the full read,
+    // as long as the result is non-zero
+    if (bytes == 0) {
+        return false;
+    }
+
+    src->cur_offset_instream += bytes;
+    src->next_input_byte = (const unsigned char*)src->fBuffer;
+    src->bytes_in_buffer = bytes;
+WHALLLOG("fill input buffer finish, bytes: %d, cur_offset: %d", bytes, src->cur_offset_instream);
+    return true;
+}
+
+static HW_BOOL sk_resync_to_restart(HwJpegInputInfo* hwInfo) {
+    sk_hw_jpeg_source_mgr*  src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+    if (!src->fStream->rewind()) {
+        WHLOG("____________failure to rewind\n");
+        return false;
+    }
+	src->cur_offset_instream = 0;
+    src->next_input_byte = (const unsigned char*)src->fBuffer;
+    src->bytes_in_buffer = 0;
+WHALLLOG("resync to start");
+    return true;
+}
+
+//static void sk_term_source(HwJpegInputInfo* /*hwInfo*/) {}
+
+static int sk_fill_buffer(HwJpegInputInfo* hwInfo, void * des, VPUMemLinear_t *newVpuMem, int w, int h){
+	sk_hw_jpeg_source_mgr*  src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+	if(des == NULL || (src->fDecoder != NULL && src->fDecoder->shouldCancelDecode())) {
+		WHLOG("return -1 at start in fill buffer.");
+		return -1;
+	}
+#if 0
+	unsigned char * destination = (unsigned char *)des;
+	long bytes = hwInfo->streamCtl.wholeStreamLength-src->cur_offset_instream;
+	long num = bytes;
+	size_t bytesOnce = sk_hw_jpeg_source_mgr::kBufferSize;
+
+	WHLOG("fill buffer: %d bytes; wholeLen:%d,curoffset:%d",bytes,hwInfo->streamCtl.wholeStreamLength,src->cur_offset_instream);
+
+	while(bytes > 0){// fix readlimit in BitmapFactory.java decodeStream in the future
+		size_t rdBytes = src->fStream->read(destination, bytesOnce);
+    	if (rdBytes <= 0) {
+			WHLOG("read fail in fill buffer.");
+        	return -1;
+    	}
+		src->cur_offset_instream += rdBytes;
+		destination += rdBytes;
+		bytes -= rdBytes;
+		if(bytes < sk_hw_jpeg_source_mgr::kBufferSize){
+			bytesOnce = bytes;
+		}
+	}
+    src->next_input_byte = (const unsigned char*)src->fBuffer;
+    src->bytes_in_buffer = 0;
+	return num;
+#else
+	SkStream *stream = NULL;
+	size_t rdBytes = -1;
+	long bytes = 0;
+	char *destination = (char*)des;
+	size_t *bytesHasIn = NULL;
+	if(src->isVpuMem){
+		stream = ((SkJpegVPUMemStream*)(src->fStream))->baseStream;
+		bytesHasIn = &(((SkJpegVPUMemStream*)(src->fStream))->bytesInStream);
+		bytes = hwInfo->streamCtl.wholeStreamLength - *bytesHasIn;
+WHLOG("bytes: %d, hwInfo->streamCtl.wholeStreamLength: %d,  *bytesHasIn: %d", bytes, hwInfo->streamCtl.wholeStreamLength, *bytesHasIn);
+		if(bytes <= 0){
+			hwInfo->streamCtl.wholeStreamLength = *bytesHasIn;
+			goto HANDLE;
+			//return hwInfo->streamCtl.wholeStreamLength;
+		} else if(bytes > hwInfo->streamCtl.wholeStreamLength){
+			return -1;
+		}
+		destination += *bytesHasIn;
+	} else {
+		bytes = hwInfo->streamCtl.wholeStreamLength-src->cur_offset_instream;
+		stream = src->fStream;
+	}
+	rdBytes = stream->read(destination, bytes);
+WHLOG("REAL rdbytes: %d", rdBytes);
+    if (bytes > 0) {
+        if (rdBytes <=0 || rdBytes > bytes) {
+            if(NULL != bytesHasIn ){
+                //vpumem
+                *bytesHasIn = -1;//read error
+            }
+            return -1;
+        }
+    }
+	src->cur_offset_instream += rdBytes;
+	if(rdBytes < bytes){//recompute whole length
+		if(src->isVpuMem){
+		 	rdBytes = rdBytes + *bytesHasIn;
+		 	*bytesHasIn = rdBytes;
+		}
+		hwInfo->streamCtl.wholeStreamLength = rdBytes;
+		WHREDLOG("REAL whole stream length: %d", rdBytes);
+	}
+HANDLE:
+	//if stream getlength is wrong, will go follow codes
+	unsigned char* buf = src->fBuffer;
+	rdBytes = stream->read(buf, sk_hw_jpeg_source_mgr::kBufferSize);
+WHLOG("reReadbyte is : %d", rdBytes);
+#ifndef UNLIKELY
+#define UNLIKELY(x) __builtin_expect((x), false)
+#else 
+#error UNLIKELY has been def
+#endif
+#ifndef LIKELY
+#define LIKELY(x) __builtin_expect((x), true)
+#else
+#error LIKELY has been def
+#endif
+	if(rdBytes > 0){
+		WHREDLOG("all right , we need relloc a vpu mem, first readbyte is : %d", rdBytes);
+		VPUMemLinear_t tmpVpuMem;
+		tmpVpuMem.vir_addr = NULL;
+		int mallocSize = hwInfo->streamCtl.wholeStreamLength + rdBytes;
+		if(rdBytes < sk_hw_jpeg_source_mgr::kBufferSize){
+			mallocSize = (mallocSize + 255)&(~255);
+			if(mallocSize < JPEG_INPUT_BUFFER) {
+				mallocSize = JPEG_INPUT_BUFFER;
+			}
+			hw_jpeg_VPUMallocLinear(&tmpVpuMem, mallocSize);
+			if(LIKELY(tmpVpuMem.vir_addr != NULL)){
+				memcpy(tmpVpuMem.vir_addr, des, hwInfo->streamCtl.wholeStreamLength);
+				memcpy((unsigned char *)tmpVpuMem.vir_addr + hwInfo->streamCtl.wholeStreamLength, buf, rdBytes);
+				hwInfo->streamCtl.wholeStreamLength += rdBytes;
+				src->cur_offset_instream += rdBytes;
+			}else{
+				goto ERROR;
+			}
+		}else{
+			size_t tmp = mallocSize;
+			WHLOG("11 tmp: %d", tmp);
+			WHREDLOG("read is filling buf, and input wh: %d,%d", w , h);
+			if(LIKELY(w > 0 && h > 0)){
+				if(LIKELY(mallocSize < w*h)){
+					mallocSize = w*h;
+				}else{
+					WHLOG("readed bytes: %d, input w: %d, input h: %d", mallocSize, w, h);
+					WHLOG("net stream, now dicide the mallocSize to four times of readed bytes.");
+					mallocSize *= 4;
+				}
+			}else{
+				WHLOG("net stream, and not get w or h before, now dicide the mallocSize to four times of readed bytes.");
+				mallocSize *= 4;
+			}
+			mallocSize = (mallocSize + 255)&(~255);
+			if(mallocSize < JPEG_INPUT_BUFFER) {
+				mallocSize = JPEG_INPUT_BUFFER;
+			}
+			WHLOG("first real mallocsize: %d", mallocSize);
+			hw_jpeg_VPUMallocLinear(&tmpVpuMem, mallocSize);
+			if(LIKELY(tmpVpuMem.vir_addr != NULL)){
+				unsigned char * mem = (unsigned char*)tmpVpuMem.vir_addr;
+				memcpy(mem, des, hwInfo->streamCtl.wholeStreamLength);
+				mem += hwInfo->streamCtl.wholeStreamLength;
+				memcpy(mem, buf, rdBytes);
+				mem += rdBytes;
+#if 1
+				rdBytes = stream->read(mem, mallocSize - tmp);
+				if(rdBytes > 0){
+					tmp += rdBytes;
+					WHLOG("22 tmp: %d, rdBytes: %d", tmp, rdBytes);
+					do{
+						if(UNLIKELY(tmp >= mallocSize)){
+							WHLOG("unenough space, we need relloc a vpumem to fill data");
+							mallocSize *= 2;
+							WHLOG("second real mallocsize: %d", mallocSize);
+							VPUMemLinear_t tmpVpuMem2;
+							tmpVpuMem2.vir_addr = NULL;
+							hw_jpeg_VPUMallocLinear(&tmpVpuMem2, mallocSize);
+							if(tmpVpuMem2.vir_addr != NULL){
+								mem = (unsigned char*)tmpVpuMem2.vir_addr;
+								memcpy(mem, tmpVpuMem.vir_addr, tmp);
+								mem += tmp;
+								hw_jpeg_VPUFreeLinear(&tmpVpuMem);
+								tmpVpuMem = tmpVpuMem2;
+							}else{
+								WHREDLOG("relloc vpumem2 fail.");
+								//release vpumem
+								hw_jpeg_VPUFreeLinear(&tmpVpuMem);
+								goto ERROR;
+							}
+						}else{
+							break;
+						}
+						rdBytes = stream->read(mem, mallocSize - tmp);
+						if(rdBytes <= 0){
+							break;
+						}
+						tmp += rdBytes;
+						WHLOG("fuck tmp: %d, rdBytes: %d", tmp, rdBytes);
+					}while(true);
+				}else{
+					goto ERROR;
+				}
+#else
+				do{
+					if(UNLIKELY(tmp + sk_hw_jpeg_source_mgr::kBufferSize > mallocSize)){
+						WHLOG("unenough space, we need relloc a vpumem to fill data");
+						mallocSize *= 2;
+						VPUMemLinear_t tmpVpuMem2;
+						tmpVpuMem2.vir_addr = NULL;
+						hw_jpeg_VPUMallocLinear(&tmpVpuMem2, mallocSize);
+						if(tmpVpuMem2.vir_addr != NULL){
+							mem = (unsigned char*)tmpVpuMem2.vir_addr;
+							memcpy(mem, tmpVpuMem.vir_addr, tmp);
+							mem += tmp;
+							hw_jpeg_VPUFreeLinear(&tmpVpuMem);
+							tmpVpuMem = tmpVpuMem2;
+						}else{
+							WHREDLOG("relloc vpumem2 fail.");
+							//release vpumem
+							hw_jpeg_VPUFreeLinear(&tmpVpuMem);
+							goto ERROR;
+						}
+					}
+					rdBytes = stream->read(mem, sk_hw_jpeg_source_mgr::kBufferSize);
+					if(rdBytes <= 0){
+						break;
+					}
+					mem += rdBytes;
+					tmp += rdBytes;
+				}while(true);
+#endif
+				hwInfo->streamCtl.wholeStreamLength = tmp;
+			}else{
+				goto ERROR;
+			}
+		}
+		*newVpuMem = tmpVpuMem;
+		if(tmpVpuMem.vir_addr != NULL && src->isVpuMem){
+			((SkJpegVPUMemStream*)(src->fStream))->setNewMemory(newVpuMem, hwInfo->streamCtl.wholeStreamLength);
+		}
+	}
+    src->next_input_byte = (const unsigned char*)src->fBuffer;
+    src->bytes_in_buffer = 0;
+	return hwInfo->streamCtl.wholeStreamLength;//destination == (char*)des?rdBytes:hwInfo->streamCtl.wholeStreamLength;
+ERROR:
+	if(src->isVpuMem){
+		*bytesHasIn = -1;
+	}
+	return -1;
+#endif
+}
+
+static HW_BOOL sk_read_1_byte(HwJpegInputInfo* hwInfo, unsigned char * ch){
+	sk_hw_jpeg_source_mgr*  src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+	if(src->bytes_in_buffer == 0){
+		if(!sk_fill_input_buffer(hwInfo)) {
+			WHLOG("fill_input_buffer fail, may be at the end of the stream.");
+			return false;
+		}
+	}
+	src->bytes_in_buffer--;
+	*ch = *src->next_input_byte++;
+	return true;
+}
+
+int sk_fill_thumb(HwJpegInputInfo* hwInfo, void * thumbBuf){
+	sk_hw_jpeg_source_mgr*  src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+	if(thumbBuf == NULL || (src->fDecoder != NULL && src->fDecoder->shouldCancelDecode())) 		{
+		SkDebugf("return -1 at start in fill thumb.");
+		return -1;
+	}
+	if(!sk_seek_input_data(hwInfo, hwInfo->streamCtl.thumbOffset)){
+		SkDebugf("seek fail in fill thumb.");
+		return -1;
+	}
+#if 0
+	unsigned char * destination = (unsigned char *)thumbBuf;
+	size_t bytes = hwInfo->streamCtl.thumbLength;
+	WHLOG("fill thumb buffer: %d bytes",bytes);
+	size_t bytesOnce = sk_hw_jpeg_source_mgr::kBufferSize;
+	while(bytes > 0){// fix readlimit in BitmapFactory.java decodeStream in the future
+		size_t rdBytes = src->fStream->read(destination, bytesOnce);
+    	if (rdBytes <= 0) {
+			WHLOG("read fail in fill buffer.");
+        	return -1;
+    	}
+		src->cur_offset_instream += rdBytes;
+		destination += rdBytes;
+		bytes -= rdBytes;
+		if(bytes < sk_hw_jpeg_source_mgr::kBufferSize){
+			bytesOnce = bytes;
+		}
+	}
+#else
+	size_t bytes = src->fStream->read(thumbBuf, hwInfo->streamCtl.thumbLength);
+    if (bytes <= 0 || bytes != hwInfo->streamCtl.thumbLength) {
+		SkDebugf("read fail in fill thumb.");
+        return -1;
+    }
+	src->cur_offset_instream += bytes;
+#endif
+    src->next_input_byte = (const unsigned char*)src->fBuffer;
+    src->bytes_in_buffer = 0;
+    //SkDebugf("%s \n",__FUNCTION__);
+	return hwInfo->streamCtl.thumbLength;
+}
+
+void sk_get_vpumemInst(HwJpegInputInfo* hwInfo, VPUMemLinear_t* thumbBuf){
+	sk_hw_jpeg_source_mgr* src = (sk_hw_jpeg_source_mgr*)hwInfo->streamCtl.inStream;
+	if(!src->isVpuMem){
+		return;	
+	}
+	SkJpegVPUMemStream* stream = (SkJpegVPUMemStream*)src->fStream;
+	if(thumbBuf != NULL){
+		*thumbBuf = *(stream->getVpuMemInst());
+	}
+}
+
+/*
+static HW_BOOL sk_get_ppInfo_msg(HwJpegInputInfo* hwInfo){
+	PostProcessInfo * ppInfo = &hwInfo->ppInfo;
+	SkJPEGImageDecoder* decoder = src->fDecoder;
+	if(decoder == NULL){
+		return false;
+	}
+	
+}*/
+
+///////////////////////////////////////////////////////////////////////////////
+
+sk_hw_jpeg_source_mgr::sk_hw_jpeg_source_mgr(SkStream* stream, SkImageDecoder* decoder, HwJpegInputInfo* hwInfo, HW_BOOL vpuMem): fStream(stream) {
+    fDecoder = decoder;
+    //fBaseAddr = stream->getMemoryBase();
+	//WHLOG("BASE ADDR: %x, kBufferSize: %d, pagesize: %d", fBaseAddr, kBufferSize,getpagesize());
+	isVpuMem = vpuMem;
+    //fMemoryBase = NULL;
+    //fUnrefStream = ownStream;
+    //fMemoryBaseSize = 0;
+	info = hwInfo;
+    init_source = sk_init_source;
+    fill_input_buffer = sk_fill_input_buffer;
+    skip_input_data = sk_skip_input_data;
+    resync_to_restart = sk_resync_to_restart;
+    //term_source = sk_term_source;
+    seek_input_data = sk_seek_input_data;
+	fill_buffer = sk_fill_buffer;
+	fill_thumb = sk_fill_thumb;
+	read_1_byte = sk_read_1_byte;
+	get_vpumemInst = sk_get_vpumemInst;
+	//*get_ppInfo_msg = sk_get_ppInfo_msg;
+}
+
+sk_hw_jpeg_source_mgr::~sk_hw_jpeg_source_mgr() {
+    fStream = NULL;
+	fDecoder = NULL;
+}
+///////////////////////////////////////////////////////////////////////////////////////////////////
+SkJpegVPUMemStream::SkJpegVPUMemStream(SkStream * stream, size_t *len){
+	size_t size = *len;
+	vpuMem.vir_addr = NULL;
+	bytesInStream = 0;
+	baseStream = stream;
+	int mallocSize = (size+255)&(~255);
+	if (mallocSize < LARGEST_LENGTH)
+        mallocSize = LARGEST_LENGTH;
+	if (mallocSize < JPEG_INPUT_BUFFER) {
+		mallocSize = JPEG_INPUT_BUFFER;
+	}
+	WHLOG("SkJpegVPUMemStream size: %d ", mallocSize);
+	hw_jpeg_VPUMallocLinear(&vpuMem, mallocSize);
+	if(vpuMem.vir_addr != NULL)
+	{
+		stream->rewind();
+		bool readApp1 = false, readApp0 = false, readSof = false, error = false;
+		unsigned short twoBytes = 0;
+		unsigned char * mem = (unsigned char *)vpuMem.vir_addr;
+		while(bytesInStream < size && error == false){
+			if((bytesInStream + 2 > LARGEST_LENGTH) || (bytesInStream + 2 > mallocSize)){
+				error = true;
+				break;
+			}
+			size_t readBytes = stream->read(&twoBytes,2);//FIX ME if big edian
+			WHLOG("meet mark : 0x%x, readBytes: %d", twoBytes, readBytes);
+			error = (readBytes<=0);
+			if(error){
+				break;
+			}
+			bytesInStream += readBytes;
+			memcpy(mem, &twoBytes, sizeof(unsigned short));
+			mem += readBytes;
+			switch(twoBytes){
+				case 0xD9FF://EOI
+					readApp1 = true;
+					readApp0 = true;
+					readSof = true;
+					break;
+				case 0xD8FF://SOI
+					break;
+				case 0xE0FF://APP0
+				case 0xE1FF://APP1
+				case 0xC0FF://SOF0
+				case 0xC2FF://SOF2
+					if(twoBytes == 0xC0FF || twoBytes == 0xC2FF){
+						readSof = true;
+					} else if(twoBytes == 0xE0FF){
+						readApp0 = true;
+					}else if(twoBytes == 0xE1FF){
+						readApp1 = true;
+					}
+				default:
+					if((bytesInStream + 2 > LARGEST_LENGTH) || (bytesInStream + 2 > mallocSize)){
+						error = true;
+						break;
+					}
+					readBytes = stream->read(&twoBytes,2);
+					error = (readBytes<=0);
+					if(error){
+						break;
+					}
+					bytesInStream += readBytes;
+					memcpy(mem, &twoBytes, sizeof(unsigned short));
+					mem += readBytes;
+					twoBytes = ((twoBytes & 0x000000ff) << 8) | ((twoBytes & 0x0000ff00) >> 8);
+					if((bytesInStream + twoBytes - 2 > LARGEST_LENGTH) || (bytesInStream + twoBytes - 2 > mallocSize)){
+						error = true;
+						break;
+					}
+					readBytes = stream->read(mem,twoBytes - 2);
+					error = (readBytes<=0);
+					if(error){
+						break;
+					}
+					bytesInStream += readBytes;
+					mem += readBytes;
+					break;
+			}
+			if((readApp1 || readApp0) && readSof){
+				//just read app0 app1 sofn; optimization for decodeFile() when request size less than thumbnail in file;
+				break;			
+			}
+		}
+		//size_t bytes = stream->read(vpuMem->vir_addr,size);//read all to vpumem
+		if(error == false && bytesInStream > 0){
+			WHLOG("bytesInStream is : %d, size is : %d", bytesInStream, size);
+			if(bytesInStream < mallocSize){//!= size){
+				mem[0] = 0xFF;mem[1] = 0xD9;//set end
+			}
+			if(bytesInStream > size){
+				*len = bytesInStream;//wrong base stream length, set to bytesInStream
+			}
+			this->setMemory(vpuMem.vir_addr, *len, false);
+			//hw_jpeg_VPUMemFlush(&vpuMem);
+		} else {
+			WHLOG("read all to vpumemstream fail.");
+			this->setMemory(NULL,0);
+			hw_jpeg_VPUFreeLinear(&vpuMem);
+			vpuMem.vir_addr = NULL;
+		}
+	} else {
+		this->setMemory(NULL,0);
+	}
+}
+
+SkJpegVPUMemStream::~SkJpegVPUMemStream(){
+	if(vpuMem.vir_addr != NULL){
+		hw_jpeg_VPUFreeLinear(&vpuMem);
+	}
+}
+
+VPUMemLinear_t* SkJpegVPUMemStream::getVpuMemInst(){
+	return &vpuMem;
+}
+
+void SkJpegVPUMemStream::setNewMemory(VPUMemLinear_t *src, size_t size){
+	if(vpuMem.vir_addr != NULL){
+		hw_jpeg_VPUFreeLinear(&vpuMem);
+	}
+	vpuMem = *src;
+	bytesInStream = size;
+	this->setMemory(src->vir_addr, size, false);
+}
+
+AutoScaleBitmap::AutoScaleBitmap(){
+	finalWidth = -1;
+	finalHeight = -1;
+	bm = NULL;
+	fDecoder = NULL;
+}
+
+#ifdef DEBUG_HW_JPEG
+#include "SkTime.h"
+
+class AutoTimeMilli {
+public:
+    AutoTimeMilli(const char label[]) : fLabel(label) {
+        if (!fLabel) {
+            fLabel = "";
+        }
+        fNow = SkTime::GetMSecs();
+    }
+    ~AutoTimeMilli() {
+        SkDebugf("%s ---- Time:%d ms\n", fLabel, SkTime::GetMSecs() - fNow);
+    }
+private:
+    const char* fLabel;
+    SkMSec      fNow;
+};
+#endif
+
+AutoScaleBitmap::~AutoScaleBitmap(){
+#ifdef DEBUG_HW_JPEG
+	 //AutoTimeMilli atm("auto scale bitmap");
+#endif
+	//scale bitmap to request size
+	if(fDecoder != NULL && bm != NULL && finalWidth > 0 && finalHeight > 0){
+		if(reusebm == 0)
+		{
+			bm->setConfig(this->getConfig(), finalWidth, finalHeight);
+			bm->setIsOpaque(this->isOpaque());
+			bm->allocPixels(fDecoder->getAllocator(),NULL);
+		}
+		SkCanvas canvas(*bm);
+		SkIRect src;
+		src.set(0,0,this->width(),this->height());
+		SkRect dst;
+		dst.set(0,0,SkIntToScalar(finalWidth),SkIntToScalar(finalHeight));
+		SkPaint paint;
+		paint.setAntiAlias(true);//set AA. Since the config is the same, no need to set dither
+		canvas.drawBitmapRect(*this, &src, dst, &paint);
+		if(reusebm > 0){
+			bm->notifyPixelsChanged();
+		}
+	}
+}
+
+void AutoScaleBitmap::setSourceAndFinalWH(char reuse, uint32_t w, uint32_t h, SkBitmap* bitmap, SkImageDecoder* decoder)
+{
+	reusebm = reuse;
+	finalWidth = w;
+	finalHeight = h;
+	bm = bitmap;
+	fDecoder = decoder;
+}
+
diff --git a/src/images/SkImageDecoder_libjpeg.cpp b/src/images/SkImageDecoder_libjpeg.cpp
index 39397d4..d930b54 100644
--- a/src/images/SkImageDecoder_libjpeg.cpp
+++ b/src/images/SkImageDecoder_libjpeg.cpp
@@ -9,6 +9,9 @@
 #include "SkImageDecoder.h"
 #include "SkImageEncoder.h"
 #include "SkJpegUtility.h"
+#ifdef USE_HW_JPEG
+#include "SkHwJpegUtility.h"
+#endif
 #include "SkColorPriv.h"
 #include "SkDither.h"
 #include "SkScaledBitmapSampler.h"
@@ -530,6 +533,19 @@ static bool get_src_config(const jpeg_decompress_struct& cinfo,
     return true;
 }
 
+#define RELEASE_STREAM	do{	\
+						if(vpuStream != NULL){	\
+							delete vpuStream;	\
+						}	\
+						if(thumbPmem.reuse){	\
+							hw_jpeg_VPUFreeLinear(&thumbPmem.thumbpmem);	\
+						}	\
+						}while(false)
+						
+#ifdef USE_HW_JPEG
+#define MAX_HARDWARE_SUPPORT_INPUT_SIZE ((1<<24)-1)//the same to vpu
+#endif
+
 // vendor specific library for HW JPEG decode
 static void *sVendorLibHandle = NULL;
 typedef bool (*CanDecodeHwPtr)(void *, int);
@@ -542,35 +558,183 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
     SkAutoTime atm("JPEG Decode");
 #endif
 
-    // use HW JPEG Decoder if available
-    void *streamBuf = NULL;
-    SkMemoryStream tempStream;
-    int streamSize = stream->getLength();
-
-    if (!sVendorLibHandle)
-        sVendorLibHandle = dlopen("libjpeghw.so", RTLD_NOW);
-    if (sVendorLibHandle) {
-        if (!sCanDecodeHw)
-            sCanDecodeHw = (CanDecodeHwPtr)dlsym(sVendorLibHandle, "canDecodeHw");
-        if (!sOnJpegDecodeHw)
-            sOnJpegDecodeHw = (OnJpegDecodeHwPtr)dlsym(sVendorLibHandle, "onJpegDecodeHw");
-
-        if (sCanDecodeHw && sOnJpegDecodeHw) {
-            // check if HW Decoding is possible
-            if ((*sCanDecodeHw)(stream, (int)mode)) {
-                // and then call HW Decoder
-                if ((*sOnJpegDecodeHw)(this, stream, bm, &streamBuf)) {
-                    return true;
-                }
+#ifdef USE_HW_JPEG
+	SkStream *thumbStream = NULL;
+	SkJpegVPUMemStream *vpuStream = NULL;
+	ReusePmem thumbPmem; //if hw decode thumbnail, reuse the thumb data in pmem, do not malloc vm
+	thumbPmem.reuse = 0;
+	AutoScaleBitmap thumbBitmap;   
+	//SkDebugf("JPEG HW Decode!");
+do{
+		SkBitmap::Config config = this->getPrefConfig(k32Bit_SrcDepth, false);
+		if (config != SkBitmap::kARGB_8888_Config &&
+        config != SkBitmap::kARGB_4444_Config &&
+        config != SkBitmap::kRGB_565_Config) {
+        config = SkBitmap::kARGB_8888_Config;
+    	}
+		if (config == SkBitmap::kARGB_4444_Config){
+			WHLOG("out config: %d, is not support by hw.",config);
+			break;
+		}
+		size_t streamlen = stream->getLength();
+		if(streamlen > MAX_HARDWARE_SUPPORT_INPUT_SIZE){
+			WHLOG("input size is so large for hardware, jump to software at once.");
+			break;
+		}
+		if (SkImageDecoder::kDecodeBounds_Mode != mode) {
+        	//use hardvpu mem sometimes when it is not decodeBounds_Mode
+			bool markSupport = stream->markSupport();
+			WHLOG("markSupport: %d", markSupport);
+			if(markSupport){//only markSupport and not justcalwh
+#ifdef WH_DEBUG_JPEG
+				AutoTimeMillis atm("JPEG read stream.");
+#endif
+				//should change to mark a new value for stream?
+				vpuStream = new SkJpegVPUMemStream(stream, &streamlen);
+				if(vpuStream->getLength() <= 0){
+					WHLOG("VPU STREAM LENGTH less than ZERO!");
+					break;		
+				}
+				stream = vpuStream;
+			}
+		}
+		HwJpegInputInfo hwInfo;
+		HwJpegOutputInfo outInfo;
+		hwInfo.justcaloutwh = SkImageDecoder::kDecodeBounds_Mode != mode? 0:1;
+		outInfo.thumbPmem = &thumbPmem;
+		int pixelBytes = -1;
+		sk_hw_jpeg_source_mgr sk_hw_stream(stream,this,&hwInfo,vpuStream != NULL);
+		hwInfo.streamCtl.inStream = &sk_hw_stream;
+		hwInfo.streamCtl.wholeStreamLength = streamlen;// > 64M? break;
+		WHLOG("Stream length: %d", hwInfo.streamCtl.wholeStreamLength);
+		hwInfo.streamCtl.thumbOffset = -1;
+		hwInfo.streamCtl.thumbLength = -1;
+		hwInfo.streamCtl.useThumb = 0;
+		PostProcessInfo * ppInfo = &hwInfo.ppInfo;
+		// only these make sense for jpegs
+    	if (config == SkBitmap::kARGB_8888_Config) {
+        	ppInfo->outFomart = 1;
+			ppInfo->shouldDither = 0;
+			pixelBytes = 4;
+    	} else if (config == SkBitmap::kRGB_565_Config) {
+        	ppInfo->outFomart = 0;
+        	ppInfo->shouldDither = this->getDitherImage();
+			pixelBytes = 2;
+    	}
+		ppInfo->scale_denom = this->getSampleSize();
+		//SkDebugf("SCALE DENOM : %d, out config: %d", ppInfo->scale_denom, config);
+		ppInfo->cropX = 0;
+		ppInfo->cropY = 0;
+  		ppInfo->cropW = -1;
+  		ppInfo->cropH = -1;
+		bm->lockPixels();
+        JSAMPLE* rowptr = (JSAMPLE*)bm->getPixels();
+	//SkDebugf("rowptr: %p, bm : %p", rowptr, bm);
+        bm->unlockPixels();
+        char reuseBitmap = (rowptr != NULL)?1:0;
+		if(reuseBitmap > 0 && config != bm->getConfig()){
+			//SkDebugf("bitmap is not null, but its config is not according with require.");
+		}
+		if(hw_jpeg_decode(&hwInfo,&outInfo, &reuseBitmap, bm->width(), bm->height()) >= 0){
+			if(reuseBitmap < 0){
+			    //SkDebugf("REUSE BITMAP FAILED.");
+				if(vpuStream != NULL){
+					delete vpuStream;
+				}
+				return false;
+			}			
+			//SkDebugf("GO HARD DECODE, OUT WH: %d,%d", outInfo.outWidth,outInfo.outHeight);
+			if(!reuseBitmap){
+				bm->setConfig(config,outInfo.outWidth,outInfo.outHeight);
+                                bm->setIsOpaque(true);
+			}
+			if(hwInfo.justcaloutwh == 0){
+				if(reuseBitmap == 0){
+					if(!this->allocPixelRef(bm,NULL)){
+						if(vpuStream != NULL){
+							delete vpuStream;
+						}
+						return false;
+					}					
+				}
+				//bm->lockPixels();
+				SkAutoLockPixels alp(*bm);
+				INT32 const bpr = bm->rowBytes();
+				int height = 0;
+				JSAMPLE * rowptr = (JSAMPLE*)bm->getPixels();
+				char *srcAddr = outInfo.outAddr;
+				//SkDebugf("bpr: %d, rowptr: %x, srcAddr: %x, reuseBitmap: %d\n",bpr, rowptr, srcAddr, reuseBitmap);
+				//WHLOG("bpr: %d, rowptr: %x, srcAddr: %x",bpr, rowptr, srcAddr);
+				while(height < outInfo.outHeight){
+					memcpy(rowptr, srcAddr, bpr);
+					rowptr += bpr;
+					srcAddr += outInfo.ppscalew * pixelBytes;
+					height++;
+				}
+				if(reuseBitmap > 0){
+					bm->notifyPixelsChanged();
+				}
+				hw_jpeg_release(outInfo.decoderHandle);
+				if(vpuStream != NULL){
+					delete vpuStream;
+				}
+				//bm->unlockPixels();
+			}
+			//when just cal out wh, if next hardware error occurs, may have problem also, FIX this in future
+			return true;
+		} else {
+			if(hwInfo.justcaloutwh == 1){
+				//SkDebugf("should not go to here.");
+				break;
+			}
+			hw_jpeg_release(outInfo.decoderHandle);
+			if (this->shouldCancelDecode() || reuseBitmap < 0) {
+				if(vpuStream != NULL){
+					delete vpuStream;
+				}
+                return false;
             }
-        }
-    }
+			if(hwInfo.streamCtl.useThumb && hwInfo.streamCtl.thumbLength > 0){
+				//construct thumb source stream
+				if(thumbPmem.reuse){
+					//SkDebugf("use thumbnail data in pmem to soft decode.");
+					thumbStream = new SkMemoryStream(thumbPmem.thumbpmem.vir_addr, hwInfo.streamCtl.thumbLength, false);
+				}else{
+					//SkDebugf("use virtual mem to copy thumbnail data to soft decode.");
+					thumbStream = new SkMemoryStream(hwInfo.streamCtl.thumbLength);
+					if(sk_fill_thumb(&hwInfo, (void*)thumbStream->getMemoryBase()) > 0) {
+						//SkDebugf("sk_fiil_thumb_ok\n");
+					} else {
+						//SkDebugf("sk_fiil_thumb_bad\n");
+						delete thumbStream;
+						thumbStream =  NULL;
+					}
+				}
+				if(thumbStream != NULL){
+					stream = thumbStream;
+					this->setSampleSize(hwInfo.ppInfo.scale_denom);//set new sample size
+					if(outInfo.shouldScale)
+					{
+						thumbBitmap.setSourceAndFinalWH(reuseBitmap, outInfo.outWidth, outInfo.outHeight, bm, this);
+						bm = &thumbBitmap;
+					}
+					if(vpuStream != NULL){
+						delete vpuStream;
+						vpuStream = NULL;
+					}
+				}
+			} else {
+				//use base image
+				if(vpuStream != NULL && vpuStream->bytesInStream <= 0){
+					stream = vpuStream->baseStream;
+					delete vpuStream;
+					vpuStream = NULL;
+				}
+			}
+		}
+}while(0);
+#endif
 
-    // if HW JPEG decode failed then reset the stream
-    if (streamBuf) {
-        tempStream.setMemoryOwned(streamBuf, streamSize);
-        stream = (SkStream *)&tempStream;
-    }
 
     JPEGAutoClean autoClean;
 
@@ -583,6 +747,9 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
     // All objects need to be instantiated before this setjmp call so that
     // they will be cleaned up properly if an error occurs.
     if (setjmp(errorManager.fJmpBuf)) {
+	#ifdef USE_HW_JPEG
+	   RELEASE_STREAM;
+	#endif
         return return_false(cinfo, *bm, "setjmp");
     }
 
@@ -591,6 +758,9 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
 
     int status = jpeg_read_header(&cinfo, true);
     if (status != JPEG_HEADER_OK) {
+	#ifdef USE_HW_JPEG
+	   RELEASE_STREAM;
+	#endif
         return return_false(cinfo, *bm, "read_header");
     }
 
@@ -621,6 +791,9 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
         return bm->setConfig(config, cinfo.image_width, cinfo.image_height, 0,
                              SkBitmap::kA8_Config == config ?
                                 kPremul_SkAlphaType : kOpaque_SkAlphaType);
+	#ifdef USE_HW_JPEG
+	    RELEASE_STREAM;
+	#endif
     }
 
     /*  image_width and image_height are the original dimensions, available
@@ -647,7 +820,13 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
             return bm->setConfig(config, smpl.scaledWidth(), smpl.scaledHeight(),
                                  0, SkBitmap::kA8_Config == config ?
                                     kPremul_SkAlphaType : kOpaque_SkAlphaType);
+	    #ifdef USE_HW_JPEG
+	        RELEASE_STREAM;
+	    #endif
         } else {
+	    #ifdef USE_HW_JPEG
+	        RELEASE_STREAM;
+	    #endif
             return return_false(cinfo, *bm, "start_decompress");
         }
     }
@@ -655,6 +834,9 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
 
     // should we allow the Chooser (if present) to pick a config for us???
     if (!this->chooseFromOneChoice(config, cinfo.output_width, cinfo.output_height)) {
+	#ifdef USE_HW_JPEG
+	    RELEASE_STREAM;
+	#endif
         return return_false(cinfo, *bm, "chooseFromOneChoice");
     }
 
@@ -666,9 +848,15 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
     bm->setConfig(config, sampler.scaledWidth(), sampler.scaledHeight(), 0,
                   SkBitmap::kA8_Config != config ? kOpaque_SkAlphaType : kPremul_SkAlphaType);
     if (SkImageDecoder::kDecodeBounds_Mode == mode) {
+	#ifdef USE_HW_JPEG
+	    RELEASE_STREAM;
+	#endif
         return true;
     }
     if (!this->allocPixelRef(bm, NULL)) {
+	#ifdef USE_HW_JPEG
+	    RELEASE_STREAM;
+	#endif
         return return_false(cinfo, *bm, "allocPixelRef");
     }
 
@@ -690,6 +878,9 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
         while (cinfo.output_scanline < cinfo.output_height) {
             int row_count = jpeg_read_scanlines(&cinfo, &rowptr, 1);
             if (0 == row_count) {
+		#ifdef USE_HW_JPEG
+		    RELEASE_STREAM;
+		#endif
                 // if row_count == 0, then we didn't get a scanline,
                 // so return early.  We will return a partial image.
                 fill_below_level(cinfo.output_scanline, bm);
@@ -697,11 +888,17 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
                 break;  // Skip to jpeg_finish_decompress()
             }
             if (this->shouldCancelDecode()) {
+		#ifdef USE_HW_JPEG
+			RELEASE_STREAM;
+		#endif
                 return return_false(cinfo, *bm, "shouldCancelDecode");
             }
             rowptr += bpr;
         }
         jpeg_finish_decompress(&cinfo);
+	#ifdef USE_HW_JPEG
+	    RELEASE_STREAM;
+	#endif
         return true;
     }
 #endif
@@ -712,9 +909,16 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
 
     if (!get_src_config(cinfo, &sc, &srcBytesPerPixel)) {
         return return_false(cinfo, *bm, "jpeg colorspace");
-    }
+    } /*else {
+	#ifdef USE_HW_JPEG
+            RELEASE_STREAM;
+	#endif
+    }*/
 
     if (!sampler.begin(bm, sc, *this)) {
+	#ifdef USE_HW_JPEG
+	    RELEASE_STREAM;
+	#endif
         return return_false(cinfo, *bm, "sampler.begin");
     }
 
@@ -731,6 +935,9 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
         JSAMPLE* rowptr = (JSAMPLE*)srcRow;
         int row_count = jpeg_read_scanlines(&cinfo, &rowptr, 1);
         if (0 == row_count) {
+	    #ifdef USE_HW_JPEG
+	        RELEASE_STREAM;
+	    #endif
             // if row_count == 0, then we didn't get a scanline,
             // so return early.  We will return a partial image.
             fill_below_level(y, bm);
@@ -738,6 +945,9 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
             break;  // Skip to jpeg_finish_decompress()
         }
         if (this->shouldCancelDecode()) {
+            #ifdef USE_HW_JPEG
+	        RELEASE_STREAM;
+	    #endif
             return return_false(cinfo, *bm, "shouldCancelDecode");
         }
 
@@ -752,6 +962,9 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
         }
 
         if (!skip_src_rows(&cinfo, srcRow, sampler.srcDY() - 1)) {
+	    #ifdef USE_HW_JPEG
+		RELEASE_STREAM;
+	    #endif
             return return_false(cinfo, *bm, "skip rows");
         }
     }
@@ -759,10 +972,17 @@ bool SkJPEGImageDecoder::onDecode(SkStream* stream, SkBitmap* bm, Mode mode) {
     // we formally skip the rest, so we don't get a complaint from libjpeg
     if (!skip_src_rows(&cinfo, srcRow,
                        cinfo.output_height - cinfo.output_scanline)) {
+	#ifdef USE_HW_JPEG
+	    RELEASE_STREAM;
+	#endif
         return return_false(cinfo, *bm, "skip rows");
     }
     jpeg_finish_decompress(&cinfo);
 
+//    SkDebugf("------------------- bm2 size %d [%d %d] %d\n", bm->getSize(), bm->width(), bm->height(), bm->config());
+	#ifdef USE_HW_JPEG
+	   RELEASE_STREAM;
+	#endif
     return true;
 }
 
-- 
1.9.1

